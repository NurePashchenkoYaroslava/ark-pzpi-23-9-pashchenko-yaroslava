Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
  
Кафедра програмної інженерії 
   
  
   
Звіт 
до практичного завдання №1  
з дисципліни « Аналіз та рефакторінг коду » 
 
 
 
 
  
Виконала:                                                                          Перевірив:                    ст.гр. ПЗПІ-23-9                                                               ст. викладач катедри ПІ  Пащенко Я. О.                                                                  Сокорчук Ігор Петрович 
 
 
 
 
Харків 2025

    1. ІСТОРІЯ ЗМІН
№	Дата звернення	Версія звіту	Опис змін та виправлень
1	27.10.25	1.1	Створення початкової версії звіту, додано мету та хід роботи, основне наповнення
2	28.10.25	1.2	Форматування відповідно ДСТУ, додавання Додатків А, Б, В.



    2. МЕТА
Метою є формування розуміння значення дотримання правил оформлення програмного коду та засвоєння основних ідіоматичних підходів до написання програм мовою Python. Необхідно навчитися застосовувати принципи «пітонічного» стилю для підвищення читабельності, ефективності та зручності супроводу програмного забезпечення. Передбачається аналіз переваг використання характерних для Python конструкцій (таких як спискові включення, f-рядки, функція enumerate) порівняно з традиційними методами. Також слід розглянути найкращі практики роботи з ресурсами за допомогою менеджера контексту with, обробки значень None та використання логічних операторів (any, all, поняття «truthiness»). Сформулювати чіткі рекомендації, що покращують читабельність, ефективність та підтримуваність програмного коду.



    3. ОПИС ВИКОНАНОЇ РОБОТИ
        3.1. Вступ
У цій доповіді для ілюстрації принципів оформлення коду використано мову програмування Python. Вона є однією з найпопулярніших мов програмування, яка знаходить застосування у створенні вебсервісів (FastAPI, Flask), роботизації процесів, наукових обчисленнях (NumPy, SciPy) та розробці систем штучного інтелекту.
У контексті обробки даних та автоматизації скриптів Python став фактичним стандартом завдяки своїй зручності, багатому вибору бібліотек (Pandas, NumPy, Scikit-learn) та можливостям роботи з файлами, мережами і потоками даних. Такі скрипти часто створюються командно: один спеціаліст може відповідати за аналітику, інший за автоматизацію чи інтеграцію результатів. Саме через таку універсальність мови надзвичайно важливим є дотримання єдиних, зрозумілих стандартів коду. Код, написаний аналітиком, повинен бути легко читабельним і зрозумілим для інженера з автоматизації, який його надалі підтримуватиме або розширюватиме.
Тому у цій роботі основну увагу зосереджено на універсальних Pythonic принципах, які покращують якість програмування. Більшість із принципів, які розглянуті у цій роботі, ґрунтуються на стандарті PEP 8, який визначає вимоги до стилю та структури програмного коду. Його дотримання сприяє не лише читабельності програм, але й підвищує надійність, ефективність та узгодженість роботи команди.
        3.2. Ідіоматичні практики та рекомендації
Для ілюстрації наступних рекомендацій щодо оформлення програмного коду використано приклади, реалізовані мовою програмування Python. Повні фрагменти коду наведено в Додатку В. 

            3.2.1. Іменування змінних 
Розгляд варто почати з іменування змінних, функцій та класів, оскільки це основа читабельності коду. Код, в якому змінні названі xudfs, abetka або data1, стає нечитабельним. Стандарт PEP 8 рекомендує чіткі конвенції, що зведені у Таблиці 3.1.
Таблиця 3.1 - Конвенції іменування (PEP 8).
Тип	Конвенція	Приклад
Змінні	snake_case (слова в нижньому регістрі, розділені підкресленням)	client_id, total_sum
Функції	snake_case (слова в нижньому регістрі, розділені підкресленням)	calculate_sum(), get_data()
Модуль	short_snake_case(коротке ім'я в нижньому регістрі, можна з підкресленням.)	db_utils.py, utils.py
Класи	CamelCase (кожне слово з великої літери, без підкреслень (також "PascalCase"))	UserLogin, DatabaseConnection
Метод (класу)	snake_case	class_method(), get_user_name()
Пакет	shortlowercase(коротке ім'я в нижньому регістрі, без підкреслень)	utils, scripts
Константи	UPPER_SNAKE_CASE (слова у верхньому регістрі, розділені підкресленням.)	MAX_RETRIES = 5, PI = 3.14
Тепер на наступних невеличких прикладах якраз і можна побачити наскільки впливає на сприйняття та розуміння різне іменування коду.
Поганий приклад:
1 # Незрозуміло, що робить функція, що містять змінні 
2 def proc(d, t): 
3 r = d / t 
4 return r 
5 res = proc(100, 5) 
Гарний приклад:
1 # Назви чітко описують призначення 
2 def calculate_average_speed(distance, time): 
3 speed = distance / time 4 return speed 
5 result = calculate_average_speed(100, 5)
Чіткі імена роблять код самодокументованим і є критично важливими в скриптах обробки даних, де логіка має бути прозорою.
            3.2.2. Ефективне створення списків: спискові включення
Наступна важлива рекомендація стосується роботи з колекціями даних. Замість того, щоб створювати порожній список і наповнювати його в циклі for, рекомендується використовувати спискові включення (List Comprehensions). Підхід з for та .append() є багатослівним (вимагає 3+ рядків) та менш ефективним, оскільки кожен виклик .append() додає накладні витрати . Спискове включення є компактним (один рядок) та оптимізованим на рівні інтерпретатора (Додаток В.1) .
            3.2.3. Коректне порівняння з None
Багато кому на практиці, при очищенні даних часто доводиться працювати з "відсутністю значення" або всім відомим null. Проте, None у Python є унікальним об'єктом (singleton). І через цю особливість, поганою практикою є порівняння через == (if my_var == None), оскільки цей оператор можна перевизначити в класі (через метод __eq__), що може призвести до неочікуваних результатів, підвищуючи ризик помилок. Єдиним правильним, швидким та коректним способом у мові програмування Python є оператор ідентичності is (if my_var is None), який перевіряє адресу в пам'яті і при відсутності значення за цією адресою видає очікуваний результат (Додаток В.2).
            3.2.4. Функції перевірки all() та any()
У багатьох мовах (C, C++, Java, C#) немає вбудованих функцій, які одразу перевіряють "чи всі" або "чи хоч один" елемент задовольняє умову. Там доводиться писати цикли вручну або використовувати сторонні бібліотеки (наприклад, у Java → stream().allMatch(...), у C# → LINQ All()/Any(), але це вже додатковий API). На відміну від них, python, надає для цього вбудовані функції all() та any(), які є зрозумілими та ефективними, оскільки вони використовують "ліниві" обчислення (short-circuiting) та зупиняються, як тільки результат стає відомим. При чому і читабельність коду стає вище, і сам він стає більш чистим (Додаток В.3).
            3.2.5. Безпечна робота з файлами
Повертачуюсь до направлення цієї доповіді, в задачах автоматизації неминуча робота з файлами, тому у даній мові програмування, критичною помилкою є ручне керування файлами через f = open() та f.close(). Якщо між цими рядками станеться помилка, файл залишиться відкритим, що призведе до витоку ресурсів. Щоб цього уникнути, завжди слід використовувати оператор with (контекстний менеджер), який гарантує автоматичне та безпечне закриття файлу. Переваги цього підходу детально описані в Таблиці 3.2 (див. також Додаток В.4).
            3.2.6. Перевірка на пусте значення
Концепція is None є частиною більш загальної ідіоми Python — "правдивості" (Truthiness) . У Python будь-який об'єкт можна оцінити як True або False в логічному контексті (наприклад, в if). Об'єкти, що вважаються "неправдивими" (Falsy), зведені в Таблиці 3.2.
Таблиця 3.2 - Основні "неправдиві" (Falsy) значення в Python
Тип	Приклади “Falsy” значень
Спеціальні значення  	None, False  
Числові типи  	0
Порожні колекції  	[] (список), () (кортеж), {} (словник), set() (множина)  
Порожні послідовності  	"" (рядок), bytes()  
Усі інші об'єкти (напр., [6, 24], "heyy", 1) вважаються "правдивими" (Truthy). Завдяки цьому, замість багатослівної перевірки if len(my_list) == 0: (яка, хоч і працює, не є ідіоматичною), рекомендований підхід для перевірки на відсутність значення є if not my_list: . В результаті, це забезпечує легшу читабельність та робить код трохи швидше, оскільки уникає явного виклику функції len() (Додаток В.5).
            3.2.7. "Атомарний" обмін змінних через розпакування кортежів
Виразність синтаксису Python проявляється і в таких операціях, як обмін значеннями змінних. У інших популярних мовах, як-от C++ або Java, ця операція вимагає трьох кроків та тимчасової змінної: temp = a; a = b; b = temp;. Подібний підхід, який є оптимальним у інших мовах, в Python показує себе не лише багатослівним, але й надлишковим, бо використовує змінну temp, яка не може використовуватися десь ще в коді . Крім того, такий спосіб схильний до людських помилок, якщо заплутатися в алгоритмі (наприклад, a = b; b = a що призведе до втрати даних). Отже, Python вирішує це через розпакування кортежів (наприклад, a, b = b, a), така операція є "атомарною" з точки зору розробника, тобто вона виконується як єдине ціле, унеможливлюючи помилки "проміжного кроку" та усуває потребу у змінній. У сфері автоматизації та обробки даних, де часто доводиться писати власні алгоритми сортування або маніпулювати елементами у списках, ця конструкція робить код значно чистішим і легшим для перевірки (Додаток В.6).

            3.2.8. Чистота процедур: неявне повернення None
Слід пам'ятати і про чистоту функцій, тому що якщо функція є процедурою (тобто не повертає обчислене значення), не потрібно писати return None в кінці. В обраній мові програмування воно автоматично повертає None за замовчуванням. Отже, написаний програмістом return None є надлишковим і вважається не потрібним, при врахуванні раніше згаданих умов (Додаток В.7).
            3.2.9. Форматування рядків
При написанні коду, окрім логічних конструкцій, які були згадані попередньо, важливе чисте форматування. До сучасних практик належить використання f-рядків (f-strings) (напр., f"Файл {filename} оброблено"). Вони є найбільш читабельним і швидким способом форматування, дозволяючи вбудовувати змінні безпосередньо в рядок. Подібний підхід вирішує проблеми всіх таких поширених методів, як:
    • Конкатенація (+): недоліком є громіздкість і те що треба перетворювати типи через str() вручну.
    • %-форматування: може стати важко читабельним коли змінних багато, та вцілому вважається застарілим.
    • Метод .format() (напр. name = "Іринка"; "добрий ранок, {}".format(name)): недоліком знову є багатослівність.
В той час f-рядки (напр. f"Hola, {name}") вважаються найчистішим, найчитабельнішим та найшвидшим методом серед вже зазначених. Таким чином, вони дозволяють вбудовувати змінні, і, разом з цим, вирази (напр., f"{price * 1.5}") безпосередньо в рядок (Додаток В.8).
            3.2.10. Використання enumerate для циклів з лічильником
Ще одна поширена практика стосується циклів, де потрібен і індекс елемента, і сам елемент. Слід уникати конструкції range(len(items)), яка вважається "анти-патерном" у Python. Пов`язано це з тим, що подібна конструкція змушує виконувати подвійний доступ до даних (i та items[i]) і, що критично для обробки даних, є негнучкою, тому що працює лише з колекціями, що мають довжину (як-от списки), і не буде коректно працювати на ітераторах або генераторах (напр., при читанні великого файлу рядок за рядком). На відміну від неї, вбудована функція enumerate вирішує обидві зазначені проблеми: вона дозволяє одночасно отримувати індекс і значення елемента без необхідності звертання до колекції за індексом і, також, працює з будь-яким ітерованим об'єктом, повертаючи пару (індекс, значення), що робить її незамінною в надійних скриптах автоматизації (Додаток В.9).
            3.2.11. Відступи як синтаксис
Завершує огляд фундаментальний аспект Python, який відрізняє його від більшості мов це правильні відступи. На відміну від C-подібних мов (напр. Java чи C++), де логічні блоки визначаються фігурними дужками {}, а відступи є лише візуальною рекомендацією, у мові Python відступи є частиною синтаксису [1]. Це філософське рішення, що втілює один з принципів "The Zen of Python" (PEP 20): "Readability counts" (Читабельність має значення) [2]. Стандарт PEP 8 чітко вимагає використовувати 4 пробіли на рівень відступу і, що важливо, наполегливо не рекомендує використовувати таби, оскільки вони можуть інтерпретуватися по-різному [1]. У задачах автоматизації це має критичне значення, тому що неправильний відступ в один пробіл може призвести не просто до IndentationError, а до прихованої логічної помилки (напр., операція, що мала виконатись після циклу, виконується на кожній ітерації), яку вкрай важко виявити (Додаток В.10).
        3.3. Програмні інструменти для підтримки стилю  
Окрім знання самих правил, у професійній розробці та обробці даних ключову роль відіграють інструменти, що автоматизують їх дотримання. Це дозволяє команді зосередитись на логіці, а не на розбіжностях про стиль. Основні інструменти поділяються на лінтери та форматери.
Спочатку розглянемо лінтери (Linters). Це інструменти статичного аналізу, які читають код, не виконуючи його, і вказують на потенційні проблеми, такі як синтаксичні помилки, порушення PEP 8, невикористані змінні або логічні помилки [3]. Вибір лінтера часто зводиться до порівняння Flake8 та Pylint (Таблиця 3.3)
Таблиця 3.3 - Порівняльний аналіз лінтерів.
Параметр  	Flake8  	Pylint  
Основна мета  	Швидка перевірка стилю (PEP 8) та логічних помилок (напр., невикористані імпорти).  	Глибокий аналіз якості коду (code smells), складності, дублювання та стандартів.  
Суворість за замовчуванням	Базова. Повідомляє лише про чіткі, об'єктивні порушення [4]	Висока. Генерує велику кількість попереджень (включно зі стилістичними), що вимагає детального налаштування [5]
Конфігурованість	Середня. Легко ігнорувати певні правила (напр., setup.cfg).	Дуже висока. Вимагає детального файлу .pylintrc для адаптації під проєкт.
Серед лінтерів Flake8 один з найпопулярніших, через свою легкість та швидкість, він комбінує перевірки стилю (pycodestyle) та логічні помилки (PyFlakes) [4]. Його часто інтегрують у CI/CD (системи неперервної інтеграції) для автоматичної перевірки коду перед злиттям гілок. 
Форматери (Formatters) на відміну від лінтерів, які лише вказують на проблеми, автоматично переписують код, приводячи його до єдиного стандарту. Тут вибір стоїть між гнучкими та "безкомпромісними" інструментами (Таблиця 3.4).
Таблиця 3.4 - Порівняльний аналіз форматерів Black та autopep8.
Параметр  	Black   	autopep8  
Підхід до форматування   	Уніфікуючий. Повністю переписує код в єдиний, неконфігурований стиль, "завершуючи суперечки" [6]  	Корекційний. Виправляє лише ті частини коду, які безпосередньо порушують стандарт PEP 8 [7] 
Конфігурованість  	Мінімальна. Навмисно не має налаштувань стилю, щоб гарантувати абсолютну уніфікацію	Висока. Можна налаштувати, які саме правила PEP 8 виправляти, а які ігнорувати 
Результат  	Код завжди буде виглядати однаково, незалежно від того, хто його написав	Виправляє лише явні порушення, залишаючи решту стилю (напр., переноси рядків) на розсуд розробника
Серед форматерів у Python часто використовується Black, його перевагою є те, що він має лише один, жорстко заданий стиль, тому в подальшому це повністю усуває будь-які розбіжності в команді про те, де ставити дужки чи переносити рядки. І в результаті, запуск однієї команди (black.) форматує весь проєкт [6].
В програмуванні мовою Python, використання комбінації Flake8 для виявлення помилок та Black для автоматичного форматування є широко розповсюдженою практикою, яка гарантує високу якість коду та відповідність стандартам PEP 8.

    4. ВИСНОВКИ
У ході виконання практичної роботи було сформовано розуміння важливості дотримання правил оформлення коду мовою Python, особливо в контексті обробки даних та автоматизації. Було детально проаналізовано 10 ключових ідіоматичних рекомендацій, що ґрунтуються на стандарті PEP 8. Отримано практичні навички застосування таких конструкцій, як спискові включення для ефективної роботи з колекціями, оператор is для коректної перевірки на None, та менеджер контексту with для безпечної роботи з файлами. Було засвоєно переваги enumerate над range(len()), f-рядків над застарілими методами форматування та важливість Truthiness для лаконічних перевірок. Також було досліджено та порівняно ключові програмні інструменти: лінтери (Flake8, Pylint) та форматери (Black, autopep8), що автоматизують підтримку стилю. Дотримання цих правил та використання інструментів безпосередньо сприяє підвищенню читабельності, надійності та підтримуваності програмного забезпечення в командній роботі.

    5. ВИКОРИСТАНІ ДЖЕРЕЛА
    1. Van Rossum G., Warsaw B., Coghlan N. PEP 8 – Style Guide for Python Code. Python.org : вебсайт. URL: https://peps.python.org/pep-0008/ (дата звернення: 27.10.2025).
    2. PEP 20 – The Zen of Python. Python.org : вебсайт. URL: https://peps.python.org/pep-0020/ (дата звернення: 27.10.2025).
    3. Hjelle G. A. Python PEP 8: How to Write Beautiful Python Code. Real Python : вебсайт. URL: https://realpython.com/python-pep8/ (дата звернення: 20.10.2025).
    4. Flake8: Your Tool For Style Guide Enforcement : вебсайт. URL: https://flake8.pycqa.org/en/latest/ (дата звернення: 28.10.2025).
    5. Pylint Documentation : вебсайт. URL: https://pylint.pycqa.org/en/latest/ (дата звернення: 28.10.2025).
    6. Black: The Uncompromising Code Formatter : вебсайт. URL: https://black.readthedocs.io/en/stable/ (дата звернення: 28.10.2025).
    7. autopep8: A tool that automatically formats Python code... : вебсайт. URL: https://pypi.org/project/autopep8/ (дата звернення: 28.10.2025).

ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/xv-uratf-PY
Хронологічний опис відеозапису:
00:00 — Вступ 
00:52 — Рекомендація 1: Спискові включення 
01:30 — Рекомендація 2: Правильне порівняння з None 
02:46 — Рекомендація 3 і 4: any(), all() та контекстний менеджер with
04:50 — Рекомендація 5 і 6: Truthiness і Розпакування кортежів 
06:35 — Рекомендації 7-10: Повернення None, форматування, робота з циклами та відступи


ДОДАТОК Б
Слайди презентації
Рисунок Б.1 - Титульний слайд.
Рисунок Б.2 - Вступ.
Рисунок Б.3 - Рекомендація 1(Використовуйте спискові включення).
Рисунок Б.4 - Рекомендація 2 (None замість null та його використання).
Рисунок Б.5 - Рекомендація 3 (Використовуйте any та all).
Рисунок Б.6 - Рекомендація 4 (Використовуйте with для роботи з файлами).
Рисунок Б.7 - Рекомендація 5 (Використовуйте правильну перевірку на пусте значення ).
Рисунок Б.8 - Рекомендація 6 (Використовуйте розпакування кортежів).
Рисунок Б.9 - Рекомендація 7 (Не повертайте None в кінці функції без необхідності).
Рисунок Б.10 - Рекомендація 8 (Використовуйте f-рядки (f-strings) для форматування).
Рисунок Б.11 - Рекомендація 9 (Використовуйте enumerate для циклів з лічильником).
Рисунок Б.10 - Рекомендація 10 (Робіть правильні відступи).
Рисунок Б.11 - Завершальний слайд.


ДОДАТОК В
Програмний код
В.1 Рекомендація 1: Спискові включення (List Comprehensions)
Поганий приклад (до рефакторингу):
1  squares = []
2  for i in range(10):
3      squares.append(i * i)

Гарний приклад (після рефакторингу):
1  squares = [i **2 for i in range(10)]

В.2 Рекомендація 2: Порівняння з None 
Поганий приклад (до рефакторингу):
1  my_var = None
2  # Потенційна помилка, оскільки '==' можна перевизначити
3  if my_var == None:
4      print("Empty")

Гарний приклад (після рефакторингу):
1  my_var = None
2  # 'is' перевіряє ідентичність об'єкта, що є точним і швидким
3  if my_var is None:
4      print("Empty")

В.3 Рекомендація 3: Використання any() та all() 
Поганий приклад (до рефакторингу):
1  numbers = [2, 4, 6]
2  all_even = True
3  for num in numbers:
4      if num % 2 != 0:
5          all_even = False
6          break
7  print(all_even)

Гарний приклад (після рефакторингу):
1  numbers = [2, 4, 6]
2  all_even = all(num % 2 == 0 for num in numbers)
3  print(all_even)

В.4 Рекомендація 4: Робота з файлами (Контекстний менеджер) 
Поганий приклад (до рефакторингу):
1  # Ризик витоку ресурсів, якщо виникне помилка
2  f = open("file.txt", "r")
3  data = f.read()
4  f.close()

Гарний приклад (після рефакторингу):
1  # 'with' гарантує, що файл буде закрито автоматично
2  with open("file.txt", "r") as f:
3      data = f.read()

В.5 Рекомендація 5: Використання "правдивості" (Truthiness) 
Поганий приклад (до рефакторингу):
1  my_list = []
2  if len(my_list) == 0:
3      print("Список порожній")

Гарний приклад (після рефакторингу):
1  my_list = []
2  if not my_list:
3      print("Список порожній")

В.6 Рекомендація 6: Розпакування кортежів (Tuple Unpacking) 
Поганий приклад (до рефакторингу):
1  a = 5
2  b = 10
3  # Використання тимчасової змінної
4  temp = a
5  a = b
6  b = temp

Гарний приклад (після рефакторингу):
1  a = 5
2  b = 10
3  a, b = b, a

В.7 Рекомендація 7: Повернення None 
Поганий приклад (до рефакторингу):

1  def setup_database(connection):
2  # робить якусь роботу  
3  print("Базу даних налаштовано.") 
4  return None # це не потрібно
Гарний приклад (після рефакторингу):
1  def setup_database(connection):
2  # робить якусь роботу  
3  print("Базу даних налаштовано.") 

В.8 Рекомендація 8: F-рядки (f-strings) для форматування 
Поганий приклад (до рефакторингу):
1  name = "Олена"
2  age = 28
3
4  # 1. Конкатенація (+) - громіздко, вимагає str()
5  print("Привіт, " + name + ", тобі " + str(age) + " років.")
6
7  # 2. %-форматування - застарілий стиль
8  print("Привіт, %s, тобі %d років." % (name, age))
9
10 # 3. Метод .format() - багатослівний
11 print("Привіт, {}, тобі {} років.".format(name, age))

Гарний приклад (після рефакторингу):
1  name = "Олена"
2  age = 28
3  print(f"Привіт, {name}, тобі {age} років.")

В.9 Рекомендація 9: Використання enumerate 
Поганий приклад (до рефакторингу):
1  items = ["яблуко", "мопс", "вишня"]
2  for i in range(len(items)):
3      print(f"{i}: {items[i]}")

Гарний приклад (після рефакторингу):
1  items = ["яблуко", "мопс", "вишня"]
2  for index, item in enumerate(items):
3      print(f"{index}: {item}")

В.10 Рекомендація 10: Правильні відступи 
Поганий приклад (до рефакторингу):
1  # 1. Використання 2 пробілів (Порушення PEP 8)
2  def my_func():
3    print("Це 2 пробіли, не 4")
4
5  # 2. Аргументи на першому рядку (Плутанина)
6  foo = long_function_name(var_one, var_two,
7      var_three, var_four)
8
9  # 3. Нечіткий відступ (відступ = 4 пробіли)
10 def long_function_name(
11     var_one, var_two, var_three,
12     var_four):
13     print(var_one) # Візуально зливається з тілом

Гарний приклад (після рефакторингу):
1  # 1. Завжди 4 пробіли для логічного блоку
2  def my_func():
3      print("Це 4 пробіли. Стандарт.")
4
5  # 2. Варіант А: Вертикальне вирівнювання
6  foo = long_function_name(var_one, var_two,
7                           var_three, var_four)
8
9  # 3. Варіант Б: "Висячий" відступ (з ДОДАТКОВИМ рівнем)
10 def long_function_name(
11         var_one, var_two, var_three, # <-- Додаткові 4 пробіли
12         var_four):
13     # Тіло функції чітко видно на своєму рівні
14     print(var_one)
